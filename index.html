<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>BRAT BOUNCE</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <style>
      :root {
        --sat: env(safe-area-inset-top, 0px);
        --sab: env(safe-area-inset-bottom, 0px);
        --sal: env(safe-area-inset-left, 0px);
        --sar: env(safe-area-inset-right, 0px);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-user-select: none;
        user-select: none;
      }

      html,
      body {
        position: fixed;
        overflow: hidden;
        background-color: #1a1a2e;
        width: 100%;
        height: 100%;
        height: 100dvh;
        touch-action: none;
      }

      #body-container {
        position: fixed;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        overflow: hidden;
        /* Width and height set by JavaScript */
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      #startpage {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        touch-action: manipulation;
      }

      #startpage > img {
        width: 100%;
        height: 100%;
        object-fit: fill;
      }

      #startplay {
        position: absolute;
        z-index: 10;
        top: 70%;
        left: 50%;
        transform: translateX(-50%);
        cursor: pointer;
        touch-action: manipulation;
        width: 60%;
        text-align: center;
      }

      #startplay img {
        width: 100%;
        max-width: 280px;
        height: auto;
      }

      button {
        outline: none;
      }
    </style>
  </head>
  <body>
    <div id="body-container">
      <canvas id="body-canvas"></canvas>

      <div id="startpage">
        <img src="https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/main-menu-L98hLTDlF3-FtOus6dD0Z2H5QPgFKDcZKFJChkQ7t.webp?aYpI" />
        <div id="startplay">
          <img src="https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/play-button-r33AtCDDY1-hwobctrYMCN2G3VFya5xuXhcyUPWIn.webp?ZU9Q" />
        </div>
      </div>
    </div>

    <script>
      // ==========================================
      // CONSTANTS - All magic numbers in one place
      // ==========================================
      const CANVAS_HEIGHT = 600;
      const CANVAS_WIDTH = 400;

      // Player constants (square character image)
      const DOODLE_WIDTH = 70;
      const DOODLE_HEIGHT = 70;
      const PLAYER_GRAVITY = 0.2;
      const PLAYER_MOVE_SPEED = 5.5;
      const PLAYER_DRUNK_SPEED = 6.5;

      // Platform constants (1.5:1 ratio images)
      const PLATFORM_WIDTH = 70;
      const PLATFORM_HEIGHT = 47;
      const PLATFORM_GAP_MIN = 80;
      const PLATFORM_GAP_MAX = 110;

      // Bullet constants
      const BULLET_RADIUS = 5;
      const BULLET_SPEED = 9;
      const ENEMY_BULLET_SPEED = 5;

      // Obstacle constants
      const POTHOLE_WIDTH = 80;
      const POTHOLE_HEIGHT = 80;

      // Game balance constants
      const INITIAL_CHANCES = 3;
      const JETPACK_DURATION = 3000;
      const DRUNK_DURATION = 10000;
      const INVINCIBILITY_DURATION = 1500;
      const COMBO_TIMEOUT = 2000;

      // Visual effect constants
      const SCREEN_SHAKE_DECAY = 0.9;
      const PARTICLE_GRAVITY = 0.1;
      const SQUASH_STRETCH_SPEED = 0.15;

      // ==========================================
      // UTILITY FUNCTIONS
      // ==========================================
      function getRandom(min, max) {
        return Math.floor(Math.random() * (Math.ceil(max) - Math.floor(min)) + Math.floor(min));
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      // ==========================================
      // AUDIO MANAGER WITH POOLING
      // ==========================================
      class AudioManager {
        constructor() {
          this.pools = {};
          this.muted = false;
          this.masterVolume = 0.5;
        }

        createPool(name, src, poolSize = 3) {
          this.pools[name] = {
            sounds: [],
            currentIndex: 0
          };

          for (let i = 0; i < poolSize; i++) {
            const audio = new Audio(src);
            audio.volume = this.masterVolume;
            this.pools[name].sounds.push(audio);
          }
        }

        play(name, volume = 1) {
          if (this.muted || !this.pools[name]) return;

          const pool = this.pools[name];
          const sound = pool.sounds[pool.currentIndex];

          sound.volume = this.masterVolume * volume;
          sound.currentTime = 0;
          sound.play().catch(() => {}); // Ignore autoplay errors

          pool.currentIndex = (pool.currentIndex + 1) % pool.sounds.length;
        }

        setMuted(muted) {
          this.muted = muted;
          for (const poolName in this.pools) {
            for (const sound of this.pools[poolName].sounds) {
              sound.muted = muted;
            }
          }
        }

        setVolume(volume) {
          this.masterVolume = clamp(volume, 0, 1);
        }

        stopAll() {
          for (const poolName in this.pools) {
            for (const sound of this.pools[poolName].sounds) {
              sound.pause();
              sound.currentTime = 0;
            }
          }
        }
      }

      // Global audio manager instance
      const audioManager = new AudioManager();

      // ==========================================
      // SCREEN SHAKE SYSTEM
      // ==========================================
      class ScreenShake {
        constructor() {
          this.intensity = 0;
          this.offsetX = 0;
          this.offsetY = 0;
        }

        trigger(intensity) {
          this.intensity = Math.max(this.intensity, intensity);
        }

        update() {
          if (this.intensity > 0.5) {
            this.offsetX = (Math.random() - 0.5) * this.intensity * 2;
            this.offsetY = (Math.random() - 0.5) * this.intensity * 2;
            this.intensity *= SCREEN_SHAKE_DECAY;
          } else {
            this.intensity = 0;
            this.offsetX = 0;
            this.offsetY = 0;
          }
        }

        apply(context) {
          context.translate(this.offsetX, this.offsetY);
        }

        reset(context) {
          context.translate(-this.offsetX, -this.offsetY);
        }
      }

      // ==========================================
      // PARTICLE SYSTEM
      // ==========================================
      class Particle {
        constructor(x, y, vx, vy, color, size, life) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.color = color;
          this.size = size;
          this.life = life;
          this.maxLife = life;
          this.active = true;
        }

        update(deltaTime) {
          this.x += this.vx * deltaTime;
          this.y += this.vy * deltaTime;
          this.vy += PARTICLE_GRAVITY * deltaTime;
          this.life -= deltaTime;
          if (this.life <= 0) {
            this.active = false;
          }
        }

        draw(context) {
          const alpha = this.life / this.maxLife;
          context.globalAlpha = alpha;
          context.fillStyle = this.color;
          context.beginPath();
          context.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
          context.fill();
          context.globalAlpha = 1;
        }
      }

      class ParticleSystem {
        constructor() {
          this.particles = [];
          this.pool = [];
          this.maxParticles = 200;
        }

        getParticle() {
          if (this.pool.length > 0) {
            return this.pool.pop();
          }
          return new Particle(0, 0, 0, 0, '#fff', 1, 1);
        }

        returnParticle(particle) {
          if (this.pool.length < 50) {
            this.pool.push(particle);
          }
        }

        emit(x, y, count, config) {
          for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
            const particle = this.getParticle();
            const angle = config.angle + (Math.random() - 0.5) * config.spread;
            const speed = config.speed * (0.5 + Math.random() * 0.5);

            particle.x = x;
            particle.y = y;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            particle.color = config.colors[Math.floor(Math.random() * config.colors.length)];
            particle.size = config.size * (0.5 + Math.random() * 0.5);
            particle.life = config.life * (0.5 + Math.random() * 0.5);
            particle.maxLife = particle.life;
            particle.active = true;

            this.particles.push(particle);
          }
        }

        // Preset effects
        landingDust(x, y) {
          this.emit(x, y, 8, {
            angle: -Math.PI / 2,
            spread: Math.PI,
            speed: 2,
            colors: ['#d4c4a8', '#b8a888', '#9c8c70'],
            size: 4,
            life: 30
          });
        }

        jetpackTrail(x, y) {
          this.emit(x, y, 3, {
            angle: Math.PI / 2,
            spread: 0.5,
            speed: 4,
            colors: ['#ff6600', '#ff9900', '#ffcc00'],
            size: 6,
            life: 20
          });
        }

        deathExplosion(x, y) {
          this.emit(x, y, 30, {
            angle: 0,
            spread: Math.PI * 2,
            speed: 5,
            colors: ['#ff0000', '#ff6600', '#ffff00', '#ffffff'],
            size: 8,
            life: 60
          });
        }

        enemyDeath(x, y) {
          this.emit(x, y, 15, {
            angle: 0,
            spread: Math.PI * 2,
            speed: 3,
            colors: ['#00ff00', '#88ff88', '#ffffff'],
            size: 5,
            life: 40
          });
        }

        collectPowerup(x, y) {
          this.emit(x, y, 20, {
            angle: -Math.PI / 2,
            spread: Math.PI * 2,
            speed: 3,
            colors: ['#00ffff', '#00ff88', '#88ffff'],
            size: 4,
            life: 35
          });
        }

        update(deltaTime) {
          for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update(deltaTime);
            if (!this.particles[i].active) {
              this.returnParticle(this.particles[i]);
              this.particles.splice(i, 1);
            }
          }
        }

        draw(context) {
          for (const particle of this.particles) {
            particle.draw(context);
          }
        }

        clear() {
          this.particles = [];
        }
      }

      // ==========================================
      // FLOATING TEXT SYSTEM (Score popups)
      // ==========================================
      class FloatingText {
        constructor(x, y, text, color) {
          this.x = x;
          this.y = y;
          this.text = text;
          this.color = color;
          this.life = 60;
          this.maxLife = 60;
          this.vy = -2;
          this.active = true;
        }

        update() {
          this.y += this.vy;
          this.vy *= 0.95;
          this.life--;
          if (this.life <= 0) {
            this.active = false;
          }
        }

        draw(context) {
          const alpha = this.life / this.maxLife;
          const scale = 1 + (1 - alpha) * 0.3;
          context.save();
          context.globalAlpha = alpha;
          context.font = `bold ${Math.floor(20 * scale)}px Arial`;
          context.fillStyle = this.color;
          context.textAlign = 'center';
          context.fillText(this.text, this.x, this.y);
          context.restore();
        }
      }

      class FloatingTextSystem {
        constructor() {
          this.texts = [];
        }

        add(x, y, text, color = '#ffff00') {
          this.texts.push(new FloatingText(x, y, text, color));
        }

        update() {
          for (let i = this.texts.length - 1; i >= 0; i--) {
            this.texts[i].update();
            if (!this.texts[i].active) {
              this.texts.splice(i, 1);
            }
          }
        }

        draw(context) {
          for (const text of this.texts) {
            text.draw(context);
          }
        }

        clear() {
          this.texts = [];
        }
      }

      // ==========================================
      // OBJECT POOL FOR BULLETS
      // ==========================================
      class BulletPool {
        constructor(context) {
          this.context = context;
          this.pool = [];
          this.active = [];
        }

        get(xCentre, yCentre) {
          let bullet;
          if (this.pool.length > 0) {
            bullet = this.pool.pop();
            bullet.xCentre = xCentre;
            bullet.yCentre = yCentre;
            bullet.active = true;
          } else {
            bullet = new Bullet(xCentre, yCentre, this.context);
          }
          this.active.push(bullet);
          return bullet;
        }

        release(bullet) {
          bullet.active = false;
          const index = this.active.indexOf(bullet);
          if (index > -1) {
            this.active.splice(index, 1);
            this.pool.push(bullet);
          }
        }

        clear() {
          this.pool = this.pool.concat(this.active);
          this.active = [];
        }
      }

      // ==========================================
      // BOOSTER CLASS
      // ==========================================
      class Booster {
        constructor(booster, x, y, context, type) {
          this.x = x;
          this.y = y;
          this.booster = booster;
          if (type == 1) {
            // Trampoline - bigger for visibility
            this.width = 85;
            this.height = 57;
          } else if (type == 2) {
            // Spring (1.5:1 ratio image)
            this.width = 60;
            this.height = 40;
          } else if (type == 4) {
            // Drinking glass potion (square image)
            this.width = 50;
            this.height = 50;
          } else {
            // Jetpack (square image)
            this.width = 50;
            this.height = 50;
          }
          this.type = type;
          this.context = context;

          // Animation properties
          this.bobOffset = Math.random() * Math.PI * 2;
          this.bobSpeed = 0.05;
          this.bobAmount = 3;
        }

        drawBooster() {
          if (this.booster && this.booster.complete && this.booster.naturalWidth !== 0) {
            // Add bobbing animation
            const bobY = Math.sin(this.bobOffset) * this.bobAmount;
            this.bobOffset += this.bobSpeed;
            this.context.drawImage(this.booster, this.x, this.y + bobY, this.width, this.height);
          }
        }

        moveDownBooster(value) {
          this.y += -value;
        }
      }

      // ==========================================
      // BULLET CLASS
      // ==========================================
      const SAUSAGE_SIZE = 25; // Size of the sausage projectile

      class Bullet {
        constructor(xCentre, yCentre, context) {
          this.xCentre = xCentre;
          this.yCentre = yCentre;
          this.context = context;
          this.radius = BULLET_RADIUS;
          this.active = true;
          this.trail = [];
          this.maxTrailLength = 5;
          this.rotation = 0; // For spinning sausage
          this.rotationSpeed = 0.3; // How fast it spins
        }

        bulletDraw(status) {
          if (status === "isDoodle" && SPRITES.sausage) {
            // Draw spinning sausage for player bullets
            this.context.save();
            const centerX = this.xCentre;
            const centerY = this.yCentre;
            this.context.translate(centerX, centerY);
            this.context.rotate(this.rotation);
            this.context.drawImage(
              SPRITES.sausage,
              -SAUSAGE_SIZE / 2,
              -SAUSAGE_SIZE / 2,
              SAUSAGE_SIZE,
              SAUSAGE_SIZE
            );
            this.context.restore();
          } else {
            // Draw enemy bullet with glow (red)
            // Draw trail
            for (let i = 0; i < this.trail.length; i++) {
              const alpha = i / this.trail.length * 0.5;
              const size = this.radius * (i / this.trail.length);
              this.context.globalAlpha = alpha;
              this.context.beginPath();
              this.context.arc(this.trail[i].x, this.trail[i].y, size, 0, 2 * Math.PI);
              this.context.fillStyle = "red";
              this.context.fill();
            }
            this.context.globalAlpha = 1;

            // Draw bullet with glow
            this.context.beginPath();
            this.context.arc(this.xCentre - this.radius, this.yCentre - this.radius, BULLET_RADIUS, 0, 2 * Math.PI);

            // Glow effect
            const gradient = this.context.createRadialGradient(
              this.xCentre - this.radius, this.yCentre - this.radius, 0,
              this.xCentre - this.radius, this.yCentre - this.radius, BULLET_RADIUS * 2
            );
            gradient.addColorStop(0, "rgba(255, 100, 100, 1)");
            gradient.addColorStop(0.5, "rgba(255, 0, 0, 0.8)");
            gradient.addColorStop(1, "rgba(255, 0, 0, 0)");
            this.context.fillStyle = gradient;
            this.context.fill();

            // Core
            this.context.beginPath();
            this.context.arc(this.xCentre - this.radius, this.yCentre - this.radius, BULLET_RADIUS * 0.6, 0, 2 * Math.PI);
            this.context.fillStyle = "#ff6666";
            this.context.fill();
          }
        }

        bulletMove(theta, status) {
          // Store trail position for enemy bullets
          if (status === "isEnemy") {
            this.trail.push({ x: this.xCentre - this.radius, y: this.yCentre - this.radius });
            if (this.trail.length > this.maxTrailLength) {
              this.trail.shift();
            }
          }

          // Update rotation for spinning sausage
          this.rotation += this.rotationSpeed;

          if (status === "isDoodle") {
            this.yCentre -= BULLET_SPEED;
          }
          if (status === "isEnemy") {
            this.yCentre += ENEMY_BULLET_SPEED * Math.sin(theta);
            this.xCentre += ENEMY_BULLET_SPEED * Math.cos(theta);
          }
        }
      }

      // ==========================================
      // DOODLE (PLAYER) CLASS
      // ==========================================
      class Doodle {
        constructor(x, y, context) {
          this.width = DOODLE_WIDTH;
          this.height = DOODLE_HEIGHT;
          this.baseWidth = DOODLE_WIDTH;
          this.baseHeight = DOODLE_HEIGHT;
          this.gravity = PLAYER_GRAVITY;
          this.x = x;
          this.y = y;
          this.context = context;
          this.isJetpacking = false;
          this.boostJetpack = 0;
          this.direction = "isFalling";
          this.offset = 0.1;
          this.collisionMode = 1;

          // Visual feedback properties
          this.scaleX = 1;
          this.scaleY = 1;
          this.targetScaleX = 1;
          this.targetScaleY = 1;
          this.rotation = 0;
          this.targetRotation = 0;

          // Invincibility
          this.invincible = false;
          this.invincibleTimer = 0;
          this.flashTimer = 0;
          this.visible = true;

          // Landing detection
          this.wasFlying = false;
        }

        // Squash and stretch on landing
        land() {
          this.targetScaleX = 1.3;
          this.targetScaleY = 0.7;
        }

        // Stretch when jumping
        jump() {
          this.targetScaleX = 0.8;
          this.targetScaleY = 1.2;
        }

        updateVisuals(deltaTime) {
          // Lerp scale back to normal
          this.scaleX = lerp(this.scaleX, this.targetScaleX, SQUASH_STRETCH_SPEED * deltaTime);
          this.scaleY = lerp(this.scaleY, this.targetScaleY, SQUASH_STRETCH_SPEED * deltaTime);

          // Return to normal scale
          this.targetScaleX = lerp(this.targetScaleX, 1, 0.1 * deltaTime);
          this.targetScaleY = lerp(this.targetScaleY, 1, 0.1 * deltaTime);

          // Slight rotation based on horizontal movement
          this.rotation = lerp(this.rotation, this.targetRotation, 0.1 * deltaTime);

          // Invincibility flashing
          if (this.invincible) {
            this.invincibleTimer -= deltaTime * 16.67; // Approximate ms
            this.flashTimer += deltaTime;
            this.visible = Math.floor(this.flashTimer * 10) % 2 === 0;
            if (this.invincibleTimer <= 0) {
              this.invincible = false;
              this.visible = true;
            }
          }
        }

        makeInvincible() {
          this.invincible = true;
          this.invincibleTimer = INVINCIBILITY_DURATION;
          this.flashTimer = 0;
        }

        drawDoodle(player, leftRight) {
          if (!this.visible) return;

          this.player = player;

          this.context.save();

          // Apply transformations from center of sprite
          const centerX = this.x + this.width / 2;
          const centerY = this.y + this.height / 2;

          this.context.translate(centerX, centerY);
          this.context.rotate(this.rotation);
          this.context.scale(this.scaleX, this.scaleY);
          this.context.translate(-centerX, -centerY);

          // Draw with slight transparency when invincible
          if (this.invincible) {
            this.context.globalAlpha = 0.8;
          }

          this.context.drawImage(this.player, this.x, this.y, this.width, this.height);

          this.context.restore();
        }

        doodleJumpSpeed(score) {
          if (score >= 800) {
            this.jumpRate = 18;
          } else if (score >= 600) {
            this.jumpRate = 18;
          } else if (score >= 400) {
            this.jumpRate = 17;
          } else if (score >= 200) {
            this.jumpRate = 15;
          } else if (score >= 50) {
            this.jumpRate = 12;
          } else {
            this.jumpRate = 10;
          }
        }

        moveDoodle(Xchange, deltaTime = 1) {
          this.offset += this.gravity * deltaTime;
          this.y = this.y + this.offset * deltaTime;
          this.x += Xchange * deltaTime;

          // Set rotation based on movement
          this.targetRotation = Xchange * 0.02;

          const wasFlying = this.direction === "isFlying";

          if (this.offset >= 0) {
            this.direction = "isFalling";
          }
          if (this.offset < 0) {
            this.direction = "isFlying";
          }

          if (this.offset < 0 && this.y <= CANVAS_HEIGHT / 2) {
            this.y = CANVAS_HEIGHT / 2 + 1;
          }

          this.wasFlying = wasFlying;
        }

        obstacleCollision(obsArray, currentLives, maxLives) {
          for (let i = 0; i < obsArray.length; i++) {
            let obs = obsArray[i];

            const obsLeft = obs.x + obs.hitboxOffsetX;
            const obsRight = obsLeft + obs.hitboxWidth;
            const obsTop = obs.y + obs.hitboxOffsetY;
            const obsBottom = obsTop + obs.hitboxHeight;

            if (
              this.x < obsRight &&
              this.x + this.width > obsLeft &&
              this.y < obsBottom &&
              this.y + this.height > obsTop
            ) {
              if (this.isJetpacking || this.invincible) {
                return { type: -1, index: -1 };
              }

              if (obs.type === 5) {
                window.FarcadeSDK?.hapticFeedback?.();
                this.isJetpacking = true;
                setTimeout(() => {
                  this.isJetpacking = false;
                }, JETPACK_DURATION);
                return { type: 1, index: i };
              } else if (obs.type === 6) {
                // Only collect health potion if not at max lives
                if (currentLives < maxLives) {
                  window.FarcadeSDK?.hapticFeedback?.();
                  return { type: 2, index: i };
                }
                // At max lives - ignore the potion
                return { type: -1, index: -1 };
              } else {
                window.FarcadeSDK?.hapticFeedback?.();
                return { type: 0, index: i };
              }
            }
          }
          return { type: -1, index: -1 };
        }

        jumpFromPlatform(particleSystem, platArray, boosterArray) {
          let doodleOffset = 12;
          let landed = false;
          for (var i = 0; i < platArray.length; i++) {
            if (
              this.y + this.height >= platArray[i].yPosition &&
              this.y + this.height <= platArray[i].yPosition + platArray[i].platformHeight &&
              this.x + this.width - doodleOffset >= platArray[i].xPosition &&
              this.x + doodleOffset <= platArray[i].xPosition + platArray[i].platformWidth &&
              this.direction === "isFalling"
            ) {
              if (platArray[i].platformType !== 3) {
                // Yellow platforms give a slightly higher jump
                if (platArray[i].platformType === 4) {
                  this.offset = -(this.jumpRate + 4);
                } else {
                  this.offset = -this.jumpRate;
                }
                this.collisionMode = 1;
                landed = true;

                // Visual feedback
                this.land();
                particleSystem.landingDust(this.x + this.width / 2, this.y + this.height);
                audioManager.play('jump', 0.6);
                window.FarcadeSDK?.hapticFeedback?.();

                // Platform bounce animation
                platArray[i].bounce();
              } else {
                platArray[i].fakePlatDetect = 1;
              }
              break;
            }
          }

          for (let i = 0; i < boosterArray.length; i++) {
            if (boosterArray[i].type === 1) {
              if (
                this.y + this.height >= boosterArray[i].y &&
                this.y + this.height <= boosterArray[i].y + boosterArray[i].height / 2 &&
                this.x + this.width >= boosterArray[i].x &&
                this.x <= boosterArray[i].x + boosterArray[i].width &&
                this.direction === "isFalling"
              ) {
                this.offset = -28;
                this.collisionMode = 0;
                this.jump();
                audioManager.play('trampoline', 0.7);
                break;
              }
            }

            if (boosterArray[i].type === 2) {
              if (
                this.y + this.height >= boosterArray[i].y &&
                this.y + this.height <= boosterArray[i].y + boosterArray[i].height / 2 &&
                this.x + this.width >= boosterArray[i].x &&
                this.x <= boosterArray[i].x + 10 &&
                this.direction === "isFalling"
              ) {
                this.offset = -25;
                this.collisionMode = 0;
                this.jump();
                break;
              }

              if (
                this.y + this.height >= boosterArray[i].y &&
                this.y + this.height <= boosterArray[i].y + boosterArray[i].height / 2 &&
                this.x + this.width >= boosterArray[i].x + 15 &&
                this.x <= boosterArray[i].x + boosterArray[i].width &&
                this.direction === "isFalling"
              ) {
                this.offset = -this.jumpRate;
                this.collisionMode = 1;
                break;
              }
            }

            if (boosterArray[i].type === 3) {
              let doodleOffset = 7;
              if (
                ((this.y + this.height >= boosterArray[i].y &&
                  this.y + this.height <= boosterArray[i].y + boosterArray[i].height) ||
                  (this.y - doodleOffset <= boosterArray[i].y + boosterArray[i].height &&
                    this.y + doodleOffset >= boosterArray[i].y)) &&
                this.x + this.width >= boosterArray[i].x &&
                this.x <= boosterArray[i].x + boosterArray[i].width
              ) {
                this.offset = -50;
                this.collisionMode = 0;
                boosterArray.splice(i, 1);
                this.boostJetpack = 1;
                this.isJetpacking = true;
                this.jump();
                audioManager.play('jetpack', 0.8);
                setTimeout(() => {
                  this.isJetpacking = false;
                }, JETPACK_DURATION);
                i--;
                break;
              }
            }
          }
          return landed;
        }
      }

      // ==========================================
      // OBSTACLE CLASS
      // ==========================================
      class Obstacle {
        constructor(obstacle, x, y, context, type, altSprite = null) {
          this.x = x;
          this.y = y;
          this.obstacle = obstacle;
          this.altSprite = altSprite;
          this.type = type;
          this.context = context;

          if (this.type === 1) {
            // Death hole (square image) - smaller hitbox for fairness
            this.width = 80;
            this.height = 80;
            this.hitboxOffsetX = 25;
            this.hitboxOffsetY = 25;
            this.hitboxWidth = this.width - this.hitboxOffsetX * 2;
            this.hitboxHeight = this.height - this.hitboxOffsetY * 2;
          } else if (this.type === 5 || this.type === 6) {
            // Potions (square images) - generous hitbox for pickups
            this.width = 50;
            this.height = 50;
            this.hitboxOffsetX = 5;
            this.hitboxOffsetY = 5;
            this.hitboxWidth = this.width - this.hitboxOffsetX * 2;
            this.hitboxHeight = this.height - this.hitboxOffsetY * 2;
          } else {
            // Enemies (square images) - smaller hitbox for fairness
            this.width = 55;
            this.height = 55;
            this.hitboxOffsetX = 18;
            this.hitboxOffsetY = 18;
            this.hitboxWidth = this.width - this.hitboxOffsetX * 2;
            this.hitboxHeight = this.height - this.hitboxOffsetY * 2;
          }

          this.xSpeed = 2;
          this.ySpeed = 1;

          // Animation
          this.bobOffset = Math.random() * Math.PI * 2;
          this.scaleX = 1;
          this.scaleY = 1;

          // Wing flapping animation for flying enemies (type 4)
          this.wingFlapTimer = 0;
          this.wingFlapSpeed = 8; // Frames between wing changes (lower = faster)
          this.wingUp = true;

          // Per-enemy shooting system (for types 2, 3, 4 - enemies that shoot)
          this.canShoot = this.type === 2 || this.type === 3 || this.type === 4;
          this.inRange = false;
          this.warmupTimer = 0;
          this.warmupTime = 60; // Frames before enemy can first shoot (1 sec at 60fps)
          this.isWarmedUp = false;
          this.isCharging = false;
          this.chargeTimer = 0;
          this.chargeTime = 30; // Frames of warning before shot (0.5 sec)
          this.shootCooldown = 0;
          this.shootInterval = 90 + Math.random() * 30; // 1.5-2 sec between shots (randomized)
        }

        drawObstacle() {
          // Add subtle bobbing for enemies
          const bobY = Math.sin(this.bobOffset) * 2;
          this.bobOffset += 0.05;

          this.context.save();
          const centerX = this.x + this.width / 2;
          const centerY = this.y + this.height / 2;
          this.context.translate(centerX, centerY);
          this.context.scale(this.scaleX, this.scaleY);
          this.context.translate(-centerX, -centerY);

          // Wing flapping animation for flying enemies (type 4)
          let spriteToDraw = this.obstacle;
          if (this.type === 4 && this.altSprite) {
            this.wingFlapTimer++;
            if (this.wingFlapTimer >= this.wingFlapSpeed) {
              this.wingFlapTimer = 0;
              this.wingUp = !this.wingUp;
            }
            spriteToDraw = this.wingUp ? this.obstacle : this.altSprite;
          }

          // Draw the sprite
          this.context.drawImage(spriteToDraw, this.x, this.y + bobY, this.width, this.height);

          // Visual warning when charging to shoot
          if (this.isCharging && this.canShoot) {
            // Pulsing red glow effect
            const pulse = 0.3 + Math.sin(this.chargeTimer * 0.4) * 0.3;
            this.context.fillStyle = `rgba(255, 0, 0, ${pulse})`;
            this.context.beginPath();
            this.context.arc(centerX, centerY + bobY, this.width * 0.6, 0, Math.PI * 2);
            this.context.fill();

            // Exclamation mark warning
            this.context.fillStyle = '#ff0000';
            this.context.font = 'bold 20px Arial';
            this.context.textAlign = 'center';
            this.context.fillText('!', centerX, this.y + bobY - 5);
          }

          this.context.restore();
        }

        moveDownObstacle(value) {
          this.y += -value;
        }

        // Update shooting state - returns true if ready to fire
        updateShooting(playerY, deltaTime = 1) {
          if (!this.canShoot) return false;

          // Check if enemy is in shooting range (50-350 pixels above player)
          const distance = playerY - this.y - this.height;
          const wasInRange = this.inRange;
          this.inRange = distance >= 50 && distance < 350;

          // Reset warmup if enemy leaves range
          if (!this.inRange) {
            this.isWarmedUp = false;
            this.warmupTimer = 0;
            this.isCharging = false;
            this.chargeTimer = 0;
            return false;
          }

          // Handle warmup (delay before first shot when entering range)
          if (!this.isWarmedUp) {
            this.warmupTimer += deltaTime;
            if (this.warmupTimer >= this.warmupTime) {
              this.isWarmedUp = true;
            }
            return false;
          }

          // Handle cooldown between shots
          if (this.shootCooldown > 0) {
            this.shootCooldown -= deltaTime;
            return false;
          }

          // Start charging if not already
          if (!this.isCharging) {
            this.isCharging = true;
            this.chargeTimer = 0;
          }

          // Handle charge-up animation
          this.chargeTimer += deltaTime;
          if (this.chargeTimer >= this.chargeTime) {
            // Ready to fire!
            this.isCharging = false;
            this.chargeTimer = 0;
            this.shootCooldown = this.shootInterval;
            return true;
          }

          return false;
        }

        individualMotion(deltaTime = 1) {
          if (this.type === 2) {
            this.x += this.xSpeed * deltaTime;
            if (this.x >= CANVAS_WIDTH - this.width || this.x <= 0) {
              this.xSpeed *= -1;
            }
          }

          if (this.type === 3) {
            this.x += this.xSpeed * deltaTime;
            this.y += getRandom(-1, 3) * deltaTime;
            if (this.x >= CANVAS_WIDTH - this.width || this.x <= 0) {
              this.xSpeed *= -1;
            }
          }

          if (this.type === 4) {
            this.x += this.xSpeed * deltaTime;
            this.y += this.ySpeed * deltaTime;
            if (this.x >= CANVAS_WIDTH - this.width) {
              this.xSpeed *= -1;
              this.ySpeed = 1;
            }
            if (this.x <= 0) {
              this.ySpeed = -1;
              this.xSpeed *= -1;
            }
          }
        }
      }

      // ==========================================
      // PLATFORM CLASS
      // ==========================================
      class Platform {
        constructor(x, y, cxt, type) {
          this.context = cxt;
          this.xPosition = x;
          this.jumpCount = 0;
          this.platformWidth = PLATFORM_WIDTH;
          this.platformHeight = PLATFORM_HEIGHT;
          this.yPosition = y;
          this.xSpeed = 2;
          this.platformType = type;
          this.array = [];
          this.fakePlatDetect = 0;
          this.goingTowards = "right";
          this.greenPlatform = SPRITES.greenPlatform;
          this.movingPlatform = SPRITES.movingPlatform;
          this.breakingPlatform = SPRITES.breakingPlatform;
          this.yellowPlatform = SPRITES.yellowPlatform;
          this.index = 0;

          // Animation properties
          this.scaleY = 1;
          this.targetScaleY = 1;
          this.bounceAmount = 0;

          // Breaking animation properties
          this.isBreaking = false;
          this.breakTimer = 0;
          this.shakeX = 0;
          this.fallSpeed = 0;
          this.opacity = 1;
          this.pieces = [];
        }

        startBreaking() {
          this.isBreaking = true;
          this.breakTimer = 0;
          audioManager.play('monsterCrash', 0.4);
          // Create pieces for the breaking effect
          for (let i = 0; i < 4; i++) {
            this.pieces.push({
              x: this.xPosition + (i % 2) * (PLATFORM_WIDTH / 2),
              y: this.yPosition + Math.floor(i / 2) * (PLATFORM_HEIGHT / 2),
              vx: (i % 2 === 0 ? -1 : 1) * (Math.random() * 2 + 1),
              vy: Math.random() * 2,
              rotation: 0,
              rotationSpeed: (Math.random() - 0.5) * 0.3
            });
          }
        }

        updateBreaking(deltaTime) {
          if (!this.isBreaking) return false;

          this.breakTimer += deltaTime;

          // Shake phase (first 10 frames)
          if (this.breakTimer < 10) {
            this.shakeX = (Math.random() - 0.5) * 6;
          } else {
            // Fall apart phase
            this.shakeX = 0;
            this.opacity = Math.max(0, this.opacity - 0.08 * deltaTime);

            for (const piece of this.pieces) {
              piece.vy += 0.5 * deltaTime;
              piece.x += piece.vx * deltaTime;
              piece.y += piece.vy * deltaTime;
              piece.rotation += piece.rotationSpeed * deltaTime;
            }
          }

          // Return true when animation is done
          return this.opacity <= 0;
        }

        bounce() {
          this.targetScaleY = 0.6;
          this.bounceAmount = 1;
        }

        updateAnimation(deltaTime) {
          this.scaleY = lerp(this.scaleY, this.targetScaleY, 0.2 * deltaTime);
          this.targetScaleY = lerp(this.targetScaleY, 1, 0.15 * deltaTime);
        }

        drawPlatform() {
          this.context.save();

          // Apply scale from center bottom
          const centerX = this.xPosition + this.platformWidth / 2;
          const bottomY = this.yPosition + this.platformHeight;

          this.context.translate(centerX, bottomY);
          this.context.scale(1, this.scaleY);
          this.context.translate(-centerX, -bottomY);

          if (this.platformType === 1) {
            this.context.drawImage(this.greenPlatform, this.xPosition, this.yPosition, PLATFORM_WIDTH, PLATFORM_HEIGHT);
          }
          if (this.platformType === 2) {
            this.context.drawImage(this.movingPlatform, this.xPosition, this.yPosition, PLATFORM_WIDTH, PLATFORM_HEIGHT);
          }
          if (this.platformType === 3) {
            this.context.globalAlpha = this.opacity;
            if (this.isBreaking && this.breakTimer >= 10) {
              // Draw breaking pieces
              const pieceW = PLATFORM_WIDTH / 2;
              const pieceH = PLATFORM_HEIGHT / 2;
              for (let i = 0; i < this.pieces.length; i++) {
                const piece = this.pieces[i];
                this.context.save();
                this.context.translate(piece.x + pieceW / 2, piece.y + pieceH / 2);
                this.context.rotate(piece.rotation);
                // Draw quarter of the platform image
                const srcX = (i % 2) * (this.breakingPlatform.width / 2);
                const srcY = Math.floor(i / 2) * (this.breakingPlatform.height / 2);
                this.context.drawImage(
                  this.breakingPlatform,
                  srcX, srcY,
                  this.breakingPlatform.width / 2, this.breakingPlatform.height / 2,
                  -pieceW / 2, -pieceH / 2,
                  pieceW, pieceH
                );
                this.context.restore();
              }
            } else {
              // Draw normal or shaking platform
              this.context.drawImage(
                this.breakingPlatform,
                this.xPosition + this.shakeX,
                this.yPosition,
                PLATFORM_WIDTH,
                PLATFORM_HEIGHT
              );
            }
            this.context.globalAlpha = 1;
          }
          if (this.platformType === 4) {
            this.context.drawImage(this.yellowPlatform, this.xPosition, this.yPosition, PLATFORM_WIDTH, PLATFORM_HEIGHT);
          }

          this.context.restore();
        }

        movePlatform(score, deltaTime = 1) {
          if (this.platformType === 2) {
            if (this.xPosition >= CANVAS_WIDTH - this.platformWidth) {
              this.xSpeed = Math.abs(this.xSpeed) * -1;
              this.goingTowards = "left";
            }
            if (this.xPosition <= 0) {
              this.xSpeed = Math.abs(this.xSpeed);
              this.goingTowards = "right";
            }
            this.xPosition += this.xSpeed * deltaTime;
          }
        }

        platformSpeed(score) {
          if (this.platformType === 2) {
            let speed;
            if (score < 100) speed = 2;
            else if (score < 250) speed = 4;
            else if (score < 400) speed = 5;
            else speed = 6;

            this.xSpeed = this.goingTowards === "right" ? speed : -speed;
          }
        }

        removeOverlap(platformArray) {
          this.array = platformArray;
          if (this.array.length === 0) return true;

          for (let j = 0; j < this.array.length; j++) {
            const ypos = this.array[j].yPosition;
            if (
              (this.yPosition >= ypos && this.yPosition <= ypos + this.platformHeight) ||
              (this.yPosition + this.platformHeight >= ypos &&
                this.yPosition + this.platformHeight <= ypos + this.platformHeight)
            ) {
              return false;
            }
          }
          return true;
        }
      }

      // ==========================================
      // COMBO SYSTEM
      // ==========================================
      class ComboSystem {
        constructor() {
          this.count = 0;
          this.timer = 0;
          this.multiplier = 1;
          this.maxMultiplier = 5;
        }

        hit() {
          this.count++;
          this.timer = COMBO_TIMEOUT;
          this.multiplier = Math.min(1 + Math.floor(this.count / 2), this.maxMultiplier);
          return this.multiplier;
        }

        update(deltaTime) {
          if (this.timer > 0) {
            this.timer -= deltaTime * 16.67;
            if (this.timer <= 0) {
              this.reset();
            }
          }
        }

        reset() {
          this.count = 0;
          this.multiplier = 1;
          this.timer = 0;
        }

        draw(context) {
          if (this.count > 1) {
            const alpha = Math.min(this.timer / 500, 1);
            context.save();
            context.globalAlpha = alpha;
            context.font = 'bold 24px Arial';
            context.fillStyle = this.multiplier >= 3 ? '#ff6600' : '#ffff00';
            context.textAlign = 'right';
            context.fillText(`${this.multiplier}x COMBO!`, CANVAS_WIDTH - 20, 90);
            context.restore();
          }
        }
      }

      // ==========================================
      // MAIN GAME CLASS
      // ==========================================
      var bodyContainer = document.getElementById("body-container");
      var element = document.getElementById("body-canvas");
      var startPage = document.getElementById("startpage");
      var playOn = document.getElementById("startplay");

      function resizeGame() {
        const container = document.getElementById('body-container');

        // Use Visual Viewport API - gives exact visible area on iOS Safari
        const vv = window.visualViewport;
        const vw = vv ? vv.width : window.innerWidth;
        const vh = vv ? vv.height : window.innerHeight;

        const gameRatio = CANVAS_WIDTH / CANVAS_HEIGHT; // 400/850 = 0.47
        let width, height;

        // Fit game within viewport while maintaining aspect ratio
        if (vw / vh < gameRatio) {
          // Viewport is taller/narrower than game - fit to width
          width = vw;
          height = vw / gameRatio;
        } else {
          // Viewport is wider than game - fit to height
          height = vh;
          width = vh * gameRatio;
        }

        container.style.width = Math.floor(width) + 'px';
        container.style.height = Math.floor(height) + 'px';
      }

      // Debounce to prevent excessive resize calls
      let resizeTimeout;
      function debouncedResize() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeGame, 100);
      }

      // Initial sizing
      resizeGame();

      // Handle all resize scenarios
      window.addEventListener('resize', debouncedResize);
      window.addEventListener('orientationchange', () => setTimeout(resizeGame, 150));

      // Visual Viewport API for iOS Safari (handles toolbar changes)
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', debouncedResize);
      }

      class GAME {
        constructor(element) {
          this.canvas = element;
          const dpr = window.devicePixelRatio || 1;
          this.canvas.width = CANVAS_WIDTH * dpr;
          this.canvas.height = CANVAS_HEIGHT * dpr;
          this.context = element.getContext("2d");
          this.context.scale(dpr, dpr);

          // Sprites
          this.backgroundImage = SPRITES.background;
          this.potHole = SPRITES.potHole;
          this.player = SPRITES.player;
          this.playerLeft = SPRITES.playerLeft;
          this.playerUp = SPRITES.playerUp;
          this.uglyEnemy = SPRITES.uglyEnemy;
          this.flyingEnemyWingUp = SPRITES.flyingEnemyWingUp;
          this.flyingEnemyWingDown = SPRITES.flyingEnemyWingDown;
          this.purpleEnemy = SPRITES.purpleEnemy;
          this.booster1 = SPRITES.booster1;
          this.booster2 = SPRITES.booster2;
          this.booster3 = SPRITES.booster3;
          this.boosterJetpack = SPRITES.boosterJetpack;
          this.drinkingGlass = SPRITES.drinkingGlass;
          this.healthReinstate = SPRITES.healthReinstate;

          // Systems
          this.screenShake = new ScreenShake();
          this.particleSystem = new ParticleSystem();
          this.floatingTextSystem = new FloatingTextSystem();
          this.comboSystem = new ComboSystem();
          this.bulletPool = new BulletPool(this.context);
          this.enemyBulletPool = new BulletPool(this.context);

          // Arrays
          this.boosterTypes = [];
          this.boosterArray = [];
          this.platformArray = [];
          this.animatingPlatformArray = [];
          this.yStorage = [];
          this.bulletArray = [];
          this.platformTypes = [];
          this.obstacleArray = [];
          this.enemyBulletArray = [];
          this.theta = [];

          // Game state
          this.score = 0;
          this.bonusScore = 0;
          this.chance = INITIAL_CHANCES;
          this.status = "isPlaying";
          this.drunkenMode = 0;
          this.drunkMovementActive = false; // Keeps drunk movement until landing

          // Timing
          this.lastTime = 0;
          this.deltaTime = 1;
          this.startTime = 0;
          this.currentTime = 0;
          this.loopCount = 0;
          this.drunkStart = 0;
          this.drunkNow = 0;

          // Input state
          this.leftRight = 0;
          this.doodleXchange = 0;
          this.spacePressed = 0;
          this.doodleClicked = 0;
          this.tapTimer = null;
          this.tapElapsedTimer = null;
          this.aX = 0;
          this.aY = 0;

          // Flags
          this.checkSum = 0;
          this.boosterCheck = 0;
          this.eventsBound = false;

          // Power-up timers for UI
          this.jetpackTimeRemaining = 0;
          this.drunkTimeRemaining = 0;

          this.setUp();
        }

        setUp() {
          if (localStorage.getItem("Doodle") == null) {
            localStorage.setItem("Doodle", "0");
          }
          this.canvas.style.display = "none";
          startPage.style.display = "block";

          this.gameStarted = false;
          const startGame = () => {
            if (this.gameStarted) return;
            this.gameStarted = true;
            startPage.style.display = "none";
            this.canvas.style.display = "block";
            this.init();
            this.bindEvents();
            this.newCanvas();
            this.lastTime = performance.now();
            this.gameLoop();
          };

          // Touch for mobile - touchstart works better on iOS than pointerdown
          playOn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startGame();
          }, { passive: false });

          // Click for desktop
          playOn.addEventListener('click', (e) => {
            e.preventDefault();
            startGame();
          });
        }

        init() {
          const doodlePlatfixer = 105;
          const doodleFixer = 150;
          this.platformArray.push(new Platform(CANVAS_WIDTH / 2, CANVAS_HEIGHT - doodlePlatfixer, this.context, 1));
          this.yStorage.push(CANVAS_HEIGHT - doodlePlatfixer);
          this.newPlatform();
          this.platformArray.sort((a, b) => a.yPosition - b.yPosition);
          this.doodle = new Doodle(CANVAS_WIDTH / 2, CANVAS_HEIGHT - doodleFixer, this.context);
        }

        // Event binding - only called once!
        bindEvents() {
          if (this.eventsBound) return;
          this.eventsBound = true;

          // Track which direction keys are held and their press order
          this.keysHeld = { left: false, right: false };
          this.lastDirectionPressed = null; // 'left' or 'right'

          document.onkeydown = (event) => {
            const isDrunk = this.drunkenMode || this.drunkMovementActive;
            if (event.code === "KeyA" || event.code === "ArrowLeft") {
              this.keysHeld.left = true;
              this.lastDirectionPressed = 'left';
              this.doodleXchange = isDrunk ? -PLAYER_DRUNK_SPEED : -PLAYER_MOVE_SPEED;
              this.leftRight = 1;
            }
            if (event.code === "KeyD" || event.code === "ArrowRight") {
              this.keysHeld.right = true;
              this.lastDirectionPressed = 'right';
              this.doodleXchange = isDrunk ? PLAYER_DRUNK_SPEED : PLAYER_MOVE_SPEED;
              this.leftRight = 0;
            }
            if (event.code === "Space") {
              this.leftRight = 2;
              if (this.spacePressed === 0) {
                this.shoot();
                this.spacePressed = 1;
              }
            }
          };

          document.onkeyup = (event) => {
            const isDrunk = this.drunkenMode || this.drunkMovementActive;
            if (event.code === "KeyA" || event.code === "ArrowLeft") {
              this.keysHeld.left = false;
              // If right is still held, switch to right
              if (this.keysHeld.right) {
                this.doodleXchange = isDrunk ? PLAYER_DRUNK_SPEED : PLAYER_MOVE_SPEED;
                this.leftRight = 0;
              } else if (!isDrunk) {
                this.doodleXchange = 0;
              }
            }
            if (event.code === "KeyD" || event.code === "ArrowRight") {
              this.keysHeld.right = false;
              // If left is still held, switch to left
              if (this.keysHeld.left) {
                this.doodleXchange = isDrunk ? -PLAYER_DRUNK_SPEED : -PLAYER_MOVE_SPEED;
                this.leftRight = 1;
              } else if (!isDrunk) {
                this.doodleXchange = 0;
              }
            }
            if (event.code === "Space") {
              this.leftRight = 0;
              this.spacePressed = 0;
            }
          };

          element.onmousedown = () => {
            this.leftRight = 2;
            this.doodleClicked = 1;
            this.shoot();
            this.tapTimer = new Date();
          };

          // Mobile touch controls - move toward finger position
          this.touchActive = false;

          const handleTouch = (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const isDrunk = this.drunkenMode || this.drunkMovementActive;

            // Convert from CSS pixels to logical game coordinates
            const scaleX = CANVAS_WIDTH / rect.width;
            const touchX = (touch.clientX - rect.left) * scaleX;
            const doodleCenterX = this.doodle.x + this.doodle.width / 2;

            // Move toward finger position
            if (touchX < doodleCenterX - 20) {
              this.doodleXchange = isDrunk ? -PLAYER_DRUNK_SPEED : -PLAYER_MOVE_SPEED;
              this.leftRight = 1;
            } else if (touchX > doodleCenterX + 20) {
              this.doodleXchange = isDrunk ? PLAYER_DRUNK_SPEED : PLAYER_MOVE_SPEED;
              this.leftRight = 0;
            } else {
              if (!isDrunk) this.doodleXchange = 0;
            }
          };

          this.canvas.addEventListener('touchstart', (event) => {
            this.touchActive = true;
            handleTouch(event);
          }, { passive: false });

          this.canvas.addEventListener('touchmove', (event) => {
            if (this.touchActive) {
              handleTouch(event);
            }
          }, { passive: false });

          this.canvas.addEventListener('touchend', () => {
            this.touchActive = false;
            if (!(this.drunkenMode || this.drunkMovementActive)) {
              this.doodleXchange = 0;
            }
          });
        }

        shoot() {
          const bullet = this.bulletPool.get(
            this.doodle.x + this.doodle.width / 2,
            this.doodle.y
          );
          this.bulletArray.push(bullet);
          audioManager.play('bullet', 0.5);
        }

        platformSelect() {
          if (this.score >= 800) {
            this.platformTypes = [2, 3, 3, 3, 4, 4, 4, 4];
          } else if (this.score >= 600) {
            this.platformTypes = [2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4];
          } else if (this.score >= 400) {
            this.platformTypes = [2, 2, 2, 2, 3, 3, 3, 3, 4, 4];
          } else if (this.score >= 200) {
            this.platformTypes = [1, 1, 2, 2, 2, 3, 3, 3, 4, 4];
          } else if (this.score >= 50) {
            this.platformTypes = [1, 1, 1, 1, 2, 2, 2, 4];
          } else {
            this.platformTypes = [1];
          }
          this.platformType = this.platformTypes[Math.floor(Math.random() * this.platformTypes.length)];
        }

        boosterSelect() {
          if (this.score >= 800) {
            this.boosterTypes = [2, 1, 2, 3, 3];
          } else if (this.score >= 600) {
            this.boosterTypes = [1, 1, 2, 2, 2, 3, 3, 3, 3];
          } else if (this.score >= 400) {
            this.boosterTypes = [1, 1, 4, 4, 2, 2, 2, 2, 2, 3, 3, 3];
          } else if (this.score >= 200) {
            this.boosterTypes = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3];
          } else if (this.score >= 50) {
            this.boosterTypes = [1, 1, 1, 2, 2, 2];
          } else {
            this.boosterTypes = [3];
          }
          this.boosterType = this.boosterTypes[Math.floor(Math.random() * this.boosterTypes.length)];
        }

        obstacleSelect() {
          if (this.score >= 800) {
            this.obstacleTypes = [1, 2, 3, 2, 2, 4, 4, 5, 5];
          } else if (this.score >= 600) {
            this.obstacleTypes = [1, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6];
          } else if (this.score >= 400) {
            this.obstacleTypes = [1, 1, 3, 3, 2, 4, 4, 5, 6];
          } else if (this.score >= 200) {
            this.obstacleTypes = [1, 2, 5, 2, 3, 3, 4, 4, 5, 6, 6];
          } else if (this.score >= 50) {
            this.obstacleTypes = [1, 1, 2, 2, 4, 3, 3, 4, 5, 6, 6, 6];
          } else {
            this.obstacleTypes = [1, 5];
          }
          this.obstacleType = this.obstacleTypes[Math.floor(Math.random() * this.obstacleTypes.length)];
        }

        newPlatform() {
          this.platformSelect();
          let previousY = 0;
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const xPlatform = getRandom(0, CANVAS_WIDTH - 50);
              const yPlatform = previousY + getRandom(PLATFORM_GAP_MIN, PLATFORM_GAP_MAX - 5);
              if (yPlatform <= CANVAS_HEIGHT && this.yStorage.indexOf(yPlatform) === -1) {
                previousY = yPlatform;
                this.yStorage.push(yPlatform);
                const platform = new Platform(xPlatform, yPlatform, this.context, this.platformType);
                if (platform.removeOverlap(this.platformArray)) {
                  this.platformArray.push(platform);
                }
              }
            }
          }
        }

        newObstacle() {
          this.obstacleSelect();
          const x = getRandom(0, CANVAS_WIDTH - 50);
          const y = this.platformArray[0].yPosition - getRandom(60, 75);

          let obstacle;
          switch (this.obstacleType) {
            case 1: obstacle = new Obstacle(this.potHole, x, y, this.context, 1); break;
            case 2: obstacle = new Obstacle(this.uglyEnemy, x, y, this.context, 2); break;
            case 3: obstacle = new Obstacle(this.purpleEnemy, x, y, this.context, 3); break;
            case 4: obstacle = new Obstacle(this.flyingEnemyWingUp, x, y, this.context, 4, this.flyingEnemyWingDown); break;
            case 5: obstacle = new Obstacle(this.drinkingGlass, x, y, this.context, 5); break;
            case 6: obstacle = new Obstacle(this.healthReinstate, x, y, this.context, 6); break;
          }
          this.obstacleArray.push(obstacle);
        }

        newBooster() {
          this.boosterSelect();

          // Get width based on booster type to ensure it spawns within bounds
          let boosterWidth;
          switch (this.boosterType) {
            case 1: boosterWidth = 85; break;  // Trampoline
            case 2: boosterWidth = 60; break;  // Spring
            default: boosterWidth = 50; break; // Jetpack/other
          }

          const x = getRandom(0, CANVAS_WIDTH - boosterWidth);
          const y = this.platformArray[0].yPosition - getRandom(60, 75);

          let booster;
          switch (this.boosterType) {
            case 1: booster = new Booster(this.booster1, x, y, this.context, 1); break;
            case 2: booster = new Booster(this.booster2, x, y, this.context, 2); break;
            case 3: booster = new Booster(this.booster3, x, y, this.context, 3); break;
          }
          this.boosterArray.push(booster);
        }

        newCanvas() {
          this.context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          this.context.fillStyle = "black";
          this.context.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          this.context.drawImage(this.backgroundImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        doodleChecker() {
          if (this.doodle.x > CANVAS_WIDTH) {
            this.doodle.x = 0;
          }
          if (this.doodle.x + this.doodle.width < 0) {
            this.doodle.x = CANVAS_WIDTH - this.doodle.width;
          }
        }

        platformAlternate() {
          for (let k = 0; k < this.platformArray.length; k++) {
            // Only remove breaking platforms (type 3)
            if (this.platformArray[k].fakePlatDetect === 1 && this.platformArray[k].platformType === 3) {
              this.animatingPlatformArray.push(this.platformArray[k]);
              this.fakePlatAnimation(this.platformArray[k]);
              this.platformArray.splice(k, 1);
              k--;

              let newY = this.platformArray[0].yPosition - getRandom(60, 70);
              const obstCheck = this.obstPlatOverlap(newY);
              if (obstCheck === 0) newY -= 50;
              else if (obstCheck === 1) newY -= 60;
              else if (obstCheck === 2) newY += 35;

              if (this.boosterArray.length !== 0) {
                const boostCheck = this.boosterPlatOverlap(newY);
                if (boostCheck === 0) newY -= 35;
                else if (boostCheck === 1) newY -= 50;
                else if (boostCheck === 2) newY += 30;
              }

              let platformType = getRandom(2, 4);
              if (
                this.score < 300 &&
                this.platformArray[0].platformType === this.platformArray[1].platformType &&
                platformType === 3 &&
                this.platformArray[0].platformType === platformType
              ) {
                platformType = 2;
              }

              this.platformArray.splice(
                0, 0,
                new Platform(getRandom(0, CANVAS_WIDTH - 50), newY, this.context, platformType)
              );
            }
          }
        }

        obstPlatOverlap(y) {
          for (let m = 0; m < this.obstacleArray.length; m++) {
            const obs = this.obstacleArray[m];
            if (y <= obs.y && y + PLATFORM_HEIGHT >= obs.y) return 0;
            if (y >= obs.y && y <= obs.y + obs.height) return 1;
            if (y <= obs.y + obs.height && y > obs.y) return 2;
            break;
          }
        }

        boosterPlatOverlap(y) {
          for (let m = 0; m < this.boosterArray.length; m++) {
            const boost = this.boosterArray[m];
            if (y <= boost.y && y + PLATFORM_HEIGHT >= boost.y) return 0;
            if (y >= boost.y && y <= boost.y + boost.height) return 1;
            if (y <= boost.y + boost.height && y > boost.y) return 2;
          }
        }

        obstacleSplice() {
          for (let n = this.obstacleArray.length - 1; n >= 0; n--) {
            if (this.obstacleArray[n].y > CANVAS_HEIGHT) {
              this.obstacleArray.splice(n, 1);
            }
          }
        }

        boosterSplice() {
          for (let n = this.boosterArray.length - 1; n >= 0; n--) {
            if (this.boosterArray[n].y > CANVAS_HEIGHT) {
              this.boosterArray.splice(n, 1);
            }
          }
        }

        obstaclewiseMotion(deltaTime = 1) {
          for (const obstacle of this.obstacleArray) {
            obstacle.individualMotion(deltaTime);
          }
        }

        bulletObstacleCollide() {
          for (let i = this.bulletArray.length - 1; i >= 0; i--) {
            for (let j = this.obstacleArray.length - 1; j >= 0; j--) {
              const obs = this.obstacleArray[j];
              if (obs.type !== 1 && obs.type !== 5 && obs.type !== 6) {
                const bullet = this.bulletArray[i];
                if (
                  bullet.yCentre - bullet.radius <= obs.y + obs.height &&
                  bullet.yCentre - bullet.radius >= obs.y &&
                  bullet.xCentre > obs.x &&
                  bullet.xCentre < obs.x + obs.width
                ) {
                  // Combo and scoring
                  const multiplier = this.comboSystem.hit();
                  const points = 50 * multiplier;
                  this.bonusScore += points;

                  // Visual effects
                  this.particleSystem.enemyDeath(obs.x + obs.width / 2, obs.y + obs.height / 2);
                  this.floatingTextSystem.add(obs.x + obs.width / 2, obs.y, `+${points}`, multiplier > 1 ? '#ff6600' : '#ffff00');
                  this.screenShake.trigger(5);
                  audioManager.play('monsterCrash', 0.7);

                  // Remove enemy and bullet
                  this.obstacleArray.splice(j, 1);
                  this.bulletPool.release(bullet);
                  this.bulletArray.splice(i, 1);
                  break;
                }
              }
            }
          }
        }

        obstacleDoodlePath() {
          for (const obs of this.obstacleArray) {
            if (
              obs.type !== 1 && obs.type !== 5 && obs.type !== 6 &&
              this.doodle.y - obs.y - obs.height < CANVAS_HEIGHT / 2 + 100 &&
              this.doodle.y - obs.y - obs.height >= 50
            ) {
              const theta = Math.atan2(
                this.doodle.y - (obs.y + obs.height),
                this.doodle.x + this.doodle.width / 2 - obs.x - obs.width / 2
              );
              const bullet = this.enemyBulletPool.get(
                obs.x + obs.width / 2,
                obs.y + obs.height
              );
              this.enemyBulletArray.push(bullet);
              this.theta.push(theta);
            }
          }
        }

        enemyShotDoodle() {
          if (this.doodle.isJetpacking || this.doodle.invincible) return;

          const doodleYoffset = 20;
          const doodleXoffset = 10;

          for (let h = this.enemyBulletArray.length - 1; h >= 0; h--) {
            const bullet = this.enemyBulletArray[h];
            if (
              bullet.xCentre + bullet.radius >= this.doodle.x + doodleXoffset &&
              bullet.xCentre - bullet.radius <= this.doodle.x + this.doodle.width - doodleXoffset &&
              bullet.yCentre + bullet.radius > this.doodle.y + doodleYoffset &&
              bullet.yCentre + bullet.radius <= this.doodle.y + this.doodle.height
            ) {
              // Visual feedback
              this.screenShake.trigger(10);
              this.particleSystem.emit(
                this.doodle.x + this.doodle.width / 2,
                this.doodle.y + this.doodle.height / 2,
                10,
                { angle: 0, spread: Math.PI * 2, speed: 3, colors: ['#ff0000', '#ff6666'], size: 4, life: 30 }
              );

              this.chance--;
              this.doodle.makeInvincible();
              this.comboSystem.reset();

              if (this.chance <= 0) {
                this.gameOver();
              }

              this.enemyBulletPool.release(bullet);
              this.enemyBulletArray.splice(h, 1);
              this.theta.splice(h, 1);
              break;
            }
          }
        }

        bulletBulletCollision() {
          for (let r = this.bulletArray.length - 1; r >= 0; r--) {
            for (let t = this.enemyBulletArray.length - 1; t >= 0; t--) {
              const playerBullet = this.bulletArray[r];
              const enemyBullet = this.enemyBulletArray[t];
              if (
                playerBullet.xCentre + playerBullet.radius >= enemyBullet.xCentre - enemyBullet.radius &&
                playerBullet.xCentre - playerBullet.radius <= enemyBullet.xCentre + enemyBullet.radius &&
                playerBullet.yCentre - playerBullet.radius <= enemyBullet.yCentre + enemyBullet.radius &&
                playerBullet.yCentre - playerBullet.radius >= enemyBullet.yCentre - enemyBullet.radius
              ) {
                // Visual feedback
                this.particleSystem.emit(
                  playerBullet.xCentre, playerBullet.yCentre, 8,
                  { angle: 0, spread: Math.PI * 2, speed: 2, colors: ['#ffff00', '#ffffff'], size: 3, life: 20 }
                );

                const multiplier = this.comboSystem.hit();
                const points = 100 * multiplier;
                this.bonusScore += points;
                this.floatingTextSystem.add(playerBullet.xCentre, playerBullet.yCentre, `+${points}`, '#00ff00');

                this.bulletPool.release(playerBullet);
                this.bulletArray.splice(r, 1);
                this.enemyBulletPool.release(enemyBullet);
                this.enemyBulletArray.splice(t, 1);
                this.theta.splice(t, 1);
                break;
              }
            }
          }
        }

        fakePlatAnimation(platform) {
          platform.startBreaking();
        }

        drawUI() {
          // Score bar background
          this.context.fillStyle = "rgba(0, 0, 0, 0.5)";
          this.context.fillRect(0, 0, CANVAS_WIDTH, 55);

          // Score
          this.context.font = "bold 28px Arial";
          this.context.fillStyle = "white";
          this.context.textAlign = "left";
          this.context.fillText(`${this.score + this.bonusScore}`, 20, 38);

          // Health hearts
          for (let i = 0; i < INITIAL_CHANCES; i++) {
            const heartX = CANVAS_WIDTH - 45 - i * 30;
            const heartY = 15;
            const heartSize = 25;
            if (i < this.chance) {
              // Full heart
              this.context.globalAlpha = 1;
              this.context.drawImage(SPRITES.heart, heartX, heartY, heartSize, heartSize);
            } else {
              // Empty heart (dimmed)
              this.context.globalAlpha = 0.3;
              this.context.drawImage(SPRITES.heart, heartX, heartY, heartSize, heartSize);
            }
            this.context.globalAlpha = 1;
          }

          // Drunk mode timer
          if (this.drunkenMode) {
            const timerY = 75;
            const barWidth = 120;
            const barHeight = 24;
            const progress = this.drunkTimeRemaining / DRUNK_DURATION;

            // Background bar with rounded corners
            this.context.fillStyle = "rgba(0, 0, 0, 0.5)";
            this.context.beginPath();
            this.context.roundRect(10, timerY, barWidth, barHeight, 6);
            this.context.fill();

            // Progress fill with gradient
            const gradient = this.context.createLinearGradient(10, timerY, 10 + barWidth, timerY);
            gradient.addColorStop(0, "#b8ff00");
            gradient.addColorStop(1, "#8bc700");
            this.context.fillStyle = gradient;
            this.context.beginPath();
            this.context.roundRect(10, timerY, barWidth * progress, barHeight, 6);
            this.context.fill();

            // Border
            this.context.strokeStyle = "rgba(255, 255, 255, 0.3)";
            this.context.lineWidth = 1;
            this.context.beginPath();
            this.context.roundRect(10, timerY, barWidth, barHeight, 6);
            this.context.stroke();

            // Text with shadow
            this.context.fillStyle = "rgba(0, 0, 0, 0.5)";
            this.context.font = "bold 13px 'Arial Black', sans-serif";
            this.context.textAlign = "center";
            this.context.fillText("DRUNK", 10 + barWidth / 2 + 1, timerY + 17);
            this.context.fillStyle = "#fff";
            this.context.fillText("DRUNK", 10 + barWidth / 2, timerY + 16);
          }

          // Combo display
          this.comboSystem.draw(this.context);
        }

        gameOver() {
          this.status = "notPlaying";
          cancelAnimationFrame(this.animator);

          // Death effects
          this.particleSystem.deathExplosion(
            this.doodle.x + this.doodle.width / 2,
            this.doodle.y + this.doodle.height / 2
          );
          this.screenShake.trigger(20);

          const finalScore = this.score + this.bonusScore;
          if (finalScore > parseInt(localStorage.getItem("Doodle"))) {
            localStorage.setItem("Doodle", `${finalScore}`);
          }

          window.FarcadeSDK?.singlePlayer?.actions.gameOver?.({ score: finalScore });

          // Go back to start page after a short delay
          setTimeout(() => {
            this.canvas.style.display = "none";
            startPage.style.display = "block";
            this.restartGame();
          }, 1000);
        }

        restartGame() {
          // Allow play button to work again
          this.gameStarted = false;

          // Clear arrays
          this.boosterTypes = [];
          this.boosterArray = [];
          this.platformArray = [];
          this.animatingPlatformArray = [];
          this.yStorage = [];
          this.bulletArray = [];
          this.platformTypes = [];
          this.obstacleArray = [];
          this.enemyBulletArray = [];
          this.theta = [];

          // Clear pools
          this.bulletPool.clear();
          this.enemyBulletPool.clear();
          this.particleSystem.clear();
          this.floatingTextSystem.clear();
          this.comboSystem.reset();

          // Reset state
          this.score = 0;
          this.bonusScore = 0;
          this.leftRight = 0;
          this.checkSum = 0;
          this.boosterCheck = 0;
          this.doodleXchange = 0;
          this.spacePressed = 0;
          this.startTime = 0;
          this.currentTime = 0;
          this.loopCount = 0;
          this.chance = INITIAL_CHANCES;
          this.drunkenMode = 0;
          this.drunkMovementActive = false;
          this.status = "isPlaying";

          this.setUp();
        }

        gameLoop(currentTime = 0) {
          // Calculate delta time for consistent physics
          // Handle first frame or invalid time values
          if (currentTime === 0 || this.lastTime === 0 || currentTime <= this.lastTime) {
            this.deltaTime = 1;
            if (currentTime > 0) {
              this.lastTime = currentTime;
            }
          } else {
            this.deltaTime = Math.min((currentTime - this.lastTime) / 16.67, 3);
            this.lastTime = currentTime;
          }

          this.newCanvas();

          // Handle tap timer
          this.tapElapsedTimer = new Date();
          if (this.tapTimer !== null) {
            if (this.tapElapsedTimer - this.tapTimer <= 650) {
              this.leftRight = 2;
            }
          }

          this.animator = window.requestAnimationFrame((t) => this.gameLoop(t));

          if (this.status === "isPlaying") {
            // Apply screen shake
            this.context.save();
            this.screenShake.update();
            this.screenShake.apply(this.context);

            // Update systems
            this.particleSystem.update(this.deltaTime);
            this.floatingTextSystem.update();
            this.comboSystem.update(this.deltaTime);

            // Update power-up timers
            if (this.doodle.isJetpacking) {
              this.jetpackTimeRemaining = Math.max(0, this.jetpackTimeRemaining - this.deltaTime * 16.67);
            }
            if (this.drunkenMode) {
              this.drunkTimeRemaining = Math.max(0, this.drunkTimeRemaining - this.deltaTime * 16.67);
            }

            // Draw and update platforms
            for (const platform of this.platformArray) {
              platform.updateAnimation(this.deltaTime);
              platform.drawPlatform();
              platform.platformSpeed(this.score);
              platform.movePlatform(this.score, this.deltaTime);
            }

            // Update doodle
            this.doodle.doodleJumpSpeed(this.score);
            const landed = this.doodle.jumpFromPlatform(this.particleSystem, this.platformArray, this.boosterArray);
            if (landed && this.drunkMovementActive) {
              this.drunkMovementActive = false;
            }
            this.doodle.moveDoodle(this.doodleXchange, this.deltaTime);
            this.doodle.updateVisuals(this.deltaTime);
            this.doodleChecker();

            if (this.doodle.direction === "isFalling" && this.doodle.boostJetpack === 1) {
              this.doodle.boostJetpack = 0;
            }

            // Jetpack particles
            if (this.doodle.isJetpacking && this.doodle.boostJetpack === 1) {
              this.particleSystem.jetpackTrail(
                this.doodle.x + this.doodle.width / 2,
                this.doodle.y + this.doodle.height
              );
            }

            // Draw doodle
            if (this.doodle.boostJetpack === 0) {
              if (this.leftRight === 1) {
                this.doodle.drawDoodle(this.playerLeft, this.leftRight);
              } else if (this.leftRight === 0) {
                this.doodle.drawDoodle(this.player, this.leftRight);
              } else if (this.leftRight === 2) {
                this.doodle.drawDoodle(this.playerUp, this.leftRight);
              }
            } else {
              this.doodle.drawDoodle(this.boosterJetpack, 3);
            }

            // Update and draw bullets
            for (let i = this.bulletArray.length - 1; i >= 0; i--) {
              this.bulletArray[i].bulletMove(0, "isDoodle");
              this.bulletArray[i].bulletDraw("isDoodle");
              if (this.bulletArray[i].yCentre + this.bulletArray[i].radius < 0) {
                this.bulletPool.release(this.bulletArray[i]);
                this.bulletArray.splice(i, 1);
              }
            }

            // Spawn obstacles
            if (this.score > 0 && this.score % 19 === 0 && this.checkSum === 0) {
              this.newObstacle();
              this.checkSum = 1;
            }

            // Draw obstacles
            for (const obstacle of this.obstacleArray) {
              obstacle.drawObstacle();
            }

            // Per-enemy shooting logic
            for (const obs of this.obstacleArray) {
              // Update shooting state and check if ready to fire
              const shouldFire = obs.updateShooting(this.doodle.y, this.deltaTime);

              if (shouldFire) {
                // Calculate angle to player
                const theta = Math.atan2(
                  this.doodle.y - (obs.y + obs.height),
                  this.doodle.x + this.doodle.width / 2 - obs.x - obs.width / 2
                );

                // Create bullet
                const bullet = this.enemyBulletPool.get(
                  obs.x + obs.width / 2,
                  obs.y + obs.height
                );
                this.enemyBulletArray.push(bullet);
                this.theta.push(theta);
              }
            }

            // Update and draw enemy bullets
            for (let i = this.enemyBulletArray.length - 1; i >= 0; i--) {
              this.enemyBulletArray[i].bulletMove(this.theta[i], "isEnemy");
              this.enemyBulletArray[i].bulletDraw("isEnemy");
              if (
                this.enemyBulletArray[i].yCentre - this.enemyBulletArray[i].radius > CANVAS_HEIGHT ||
                this.enemyBulletArray[i].xCentre + this.enemyBulletArray[i].radius < 0 ||
                this.enemyBulletArray[i].xCentre - this.enemyBulletArray[i].radius > CANVAS_WIDTH
              ) {
                this.enemyBulletPool.release(this.enemyBulletArray[i]);
                this.enemyBulletArray.splice(i, 1);
                this.theta.splice(i, 1);
              }
            }

            // Spawn boosters
            if (this.score > 0 && this.score % 43 === 0 && this.boosterCheck === 0) {
              this.newBooster();
              this.boosterCheck = 1;
            }

            // Draw boosters
            for (const booster of this.boosterArray) {
              booster.drawBooster();
            }

            this.platformAlternate();

            // Scroll world when player reaches mid-screen
            if (this.doodle.y <= CANVAS_HEIGHT / 2 + 1 && this.doodle.offset < 0) {
              const scrollAmount = -this.doodle.offset;

              // Move enemy bullets
              for (const bullet of this.enemyBulletArray) {
                bullet.yCentre += scrollAmount;
              }

              // Move obstacles
              for (const obstacle of this.obstacleArray) {
                obstacle.moveDownObstacle(this.doodle.offset);
              }

              // Move boosters
              for (const booster of this.boosterArray) {
                booster.moveDownBooster(this.doodle.offset);
              }

              // Move animating platforms
              for (const platform of this.animatingPlatformArray) {
                platform.yPosition += scrollAmount;
                // Also move the breaking pieces
                for (const piece of platform.pieces) {
                  piece.y += scrollAmount;
                }
              }

              // Move and recycle platforms
              for (let k = 0; k < this.platformArray.length; k++) {
                this.platformArray[k].yPosition += scrollAmount;
                if (this.platformArray[k].yPosition >= CANVAS_HEIGHT) {
                  this.checkSum = 0;
                  this.boosterCheck = 0;

                  let newY = this.platformArray[0].yPosition - getRandom(PLATFORM_GAP_MIN, PLATFORM_GAP_MAX);

                  if (this.obstacleArray.length !== 0) {
                    const overlapCheck = this.obstPlatOverlap(newY);
                    if (overlapCheck === 0) newY -= 35;
                    else if (overlapCheck === 1) newY -= 50;
                    else if (overlapCheck === 2) newY += 30;
                  }

                  if (this.boosterArray.length !== 0) {
                    const boostCheck = this.boosterPlatOverlap(newY);
                    if (boostCheck === 0) newY -= 35;
                    else if (boostCheck === 1) newY -= 50;
                    else if (boostCheck === 2) newY += 30;
                  }

                  this.platformArray.splice(k, 1);

                  if (
                    this.score < 300 &&
                    this.platformArray[0].platformType === this.platformArray[1].platformType &&
                    this.platformType === 3 &&
                    this.platformArray[0].platformType === this.platformType
                  ) {
                    this.platformType = 2;
                  }

                  this.platformArray.splice(
                    0, 0,
                    new Platform(getRandom(0, CANVAS_WIDTH - 50), newY, this.context, this.platformType)
                  );
                  this.score += 1;
                }
              }
            }

            // Handle obstacle collision
            const collision = this.doodle.obstacleCollision(this.obstacleArray, this.chance, INITIAL_CHANCES);
            if (collision.type === 0) {
              // Hit an enemy - lose a life
              this.screenShake.trigger(15);
              this.particleSystem.emit(
                this.doodle.x + this.doodle.width / 2,
                this.doodle.y + this.doodle.height / 2,
                15,
                { angle: 0, spread: Math.PI * 2, speed: 4, colors: ['#ff0000', '#ff6666', '#ffaaaa'], size: 5, life: 35 }
              );

              this.chance--;
              this.doodle.makeInvincible();
              this.comboSystem.reset();

              // Remove the enemy
              this.obstacleArray.splice(collision.index, 1);

              if (this.chance <= 0) {
                this.gameOver();
              }
            }
            if (collision.type === 1) {
              // Jetpack power-up - remove from map
              this.obstacleArray.splice(collision.index, 1);
              this.drunkStart = new Date();
              this.drunkenMode = 1;
              this.drunkTimeRemaining = DRUNK_DURATION;
              this.particleSystem.collectPowerup(
                this.doodle.x + this.doodle.width / 2,
                this.doodle.y + this.doodle.height / 2
              );
            } else if (collision.type === 2) {
              // Health potion - remove from map and add 1 life
              this.obstacleArray.splice(collision.index, 1);
              this.chance++;
              this.particleSystem.collectPowerup(
                this.doodle.x + this.doodle.width / 2,
                this.doodle.y + this.doodle.height / 2
              );
            }

            // Drunk mode timer
            this.drunkNow = new Date();
            if (this.drunkNow - this.drunkStart >= DRUNK_DURATION && this.drunkenMode) {
              this.drunkenMode = 0;
              this.drunkMovementActive = true; // Keep movement until landing
            }

            this.obstaclewiseMotion(this.deltaTime);

            // Check for falling off screen
            if (this.doodle.y + this.doodle.height >= CANVAS_HEIGHT) {
              this.gameOver();
            }

            // Collision checks
            if (this.obstacleArray.length !== 0 && this.bulletArray.length !== 0) {
              this.bulletObstacleCollide();
            }
            if (this.enemyBulletArray.length !== 0) {
              this.enemyShotDoodle();
            }
            if (this.enemyBulletArray.length !== 0 && this.bulletArray.length !== 0) {
              this.bulletBulletCollision();
            }

            this.platformSelect();
            this.obstacleSplice();
            this.boosterSplice();

            // Draw animating (breaking) platforms
            for (let i = this.animatingPlatformArray.length - 1; i >= 0; i--) {
              const platform = this.animatingPlatformArray[i];
              const done = platform.updateBreaking(this.deltaTime);
              platform.drawPlatform();
              if (done) {
                this.animatingPlatformArray.splice(i, 1);
              }
            }

            // Draw particles and floating text
            this.particleSystem.draw(this.context);
            this.floatingTextSystem.draw(this.context);

            // Reset screen shake transform
            this.context.restore();

            // Draw UI (after screen shake reset so it's stable)
            this.drawUI();

          }
        }
      }

      // ==========================================
      // ASSET LOADING
      // ==========================================
      let assetsStillLoading = 0;
      let assetsLoader;
      let numAssets;
      let loadedPercent;
      const AUDIOS = {};
      const SPRITES = {};
      let ctx = document.getElementById("body-canvas").getContext("2d");
      const dpr = window.devicePixelRatio || 1;
      ctx.canvas.width = CANVAS_WIDTH * dpr;
      ctx.canvas.height = CANVAS_HEIGHT * dpr;
      ctx.scale(dpr, dpr);

      function assetsLoadingLoop(callback) {
        if (numAssets === 0) return;

        loadedPercent = ((numAssets - assetsStillLoading) / numAssets) * 100;

        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.textAlign = "center";
        ctx.fillStyle = "white";
        ctx.font = "30px Arial";
        ctx.fillText("Loading.....", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
        ctx.fillStyle = "#2dd";
        ctx.font = "30px Arial";
        ctx.fillText(`${parseInt(loadedPercent)}%`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);

        if (assetsStillLoading === 0) {
          callback();
          window.cancelAnimationFrame(assetsLoader);
        } else {
          assetsLoader = window.requestAnimationFrame(() => assetsLoadingLoop(callback));
        }
      }

      function loadAssets(callback) {
        function loadSprite(fileName) {
          assetsStillLoading++;
          let spriteImage = new Image();
          spriteImage.src = fileName;
          spriteImage.onload = () => assetsStillLoading--;
          spriteImage.onerror = () => {
            console.warn("Failed to load sprite:", fileName);
            assetsStillLoading--;
          };
          return spriteImage;
        }

        function loadAudio(fileName) {
          assetsStillLoading++;
          let audio = new Audio(fileName);
          audio.oncanplaythrough = () => assetsStillLoading--;
          audio.onerror = () => {
            console.warn("Failed to load audio:", fileName);
            assetsStillLoading--;
          };
          return audio;
        }

        // Sprite loading - Remix hosted URLs
        SPRITES.background = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/game-background-klSnuTfvvr-BwbSrwVCyq80lufWgMiuog4R2eOH0R.webp?Wv4h"
        );
        SPRITES.potHole = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/death-hole-6bveUOXA0S-6XU9ZgZfVQ0q4FgOtxUVFuSArZRRFk.webp?EqCL"
        );
        SPRITES.player = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/sausagedad-mJIldW4Yz7-zdyXKeZU7yIjV3AShBJ46hRHCOBWCL.webp?bVbH"
        );
        SPRITES.playerLeft = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/sausagedad-mJIldW4Yz7-zdyXKeZU7yIjV3AShBJ46hRHCOBWCL.webp?bVbH"
        );
        SPRITES.playerUp = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/sausagedad-throwing-VybykGaenZ-IC1RjOHFuEHfuy26nmqbXpt1kCFfyZ.webp?INsq"
        );
        SPRITES.uglyEnemy = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/walking-enemy1-ta3wrlps1u-PsRfI9ErSZPuvHm6fr8qyqUt39CZRP.webp?T5ut"
        );
        SPRITES.flyingEnemyWingUp = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/flying-enemy-wing-up-BH8FZG0vZ3-suNes58LyqzOOSJ2G32arbr1daXVcv.webp?CUw7"
        );
        SPRITES.flyingEnemyWingDown = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/flying-enemy-wing-down-TzoMdv74oQ-T3GWFGLOvmcvQJxlFxBMVQQ1WQGhFF.webp?P2oo"
        );
        SPRITES.purpleEnemy = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/walking-enemy1-ta3wrlps1u-PsRfI9ErSZPuvHm6fr8qyqUt39CZRP.webp?T5ut"
        );
        SPRITES.booster1 = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/trampoline-gkqKvT3M41-MRmDT1iOoK0VW1fLCtoFkouIhy3SP5.webp?EQyX"
        );
        SPRITES.booster2 = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/trampoline-gkqKvT3M41-MRmDT1iOoK0VW1fLCtoFkouIhy3SP5.webp?EQyX"
        );
        SPRITES.booster3 = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/jetpack-item-UY19kfOVli-EdI0P3TQxQM4NABwiNWQRh5IOuprbY.webp?PMN7"
        );
        SPRITES.boosterJetpack = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/jetpack-long-flame-oMJwID6wos-pv4lc3tF80DJIlAtkpEUyWyMqQsmMO.webp?5h0H"
        );
        SPRITES.drinkingGlass = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/drunk-potion-c43BZjt8kG-saGzoLZ6M7UnX6YpdHG8DIXEE8Sjzy.webp?sfWo"
        );
        SPRITES.healthReinstate = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/extra-life-potion-r90yf8dIQ1-8w2Tp4hTzj6ZIvHhmn7FwLl4TKrSu4.webp?i2QR"
        );
        SPRITES.greenPlatform = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/wooden-platform-hCNablaEqD-xWDqXz9JXGiKuJOVDL6ohjfAdMqjjN.webp?AeLf"
        );
        SPRITES.movingPlatform = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/blue-platform-q1tyo5y3Jq-54Dod8uCN4c9sUdEQiEEKhVuw9cEs2.webp?4pGj"
        );
        SPRITES.breakingPlatform = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/breaking-platform-ZdS5Dccrnv-rYydKL6sbQc9BbmqksQBf2MNaPh1HZ.webp?nY9Q"
        );
        SPRITES.yellowPlatform = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/yellow-platform-eO6XTQgTEH-lWFbhWMflnMMDCZlZ14ISf9xEVUMLp.webp?7Lcu"
        );
        SPRITES.heart = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/heart-3FgBRfAaJO-wjhUM8WPL0p3RFtyoWaobQkq7cbZjs.webp?UEss"
        );
        SPRITES.sausage = loadSprite(
          "https://remix.gg/blob/d0b815c7-f556-46cc-a896-d67fc30bca7a/sausagedads-sausage-Uv1fXNY29J-JLLP0ZMpsktgFoTfY8sdOsj5i7zHnZ.webp?uC21"
        );

        // Audio loading
        AUDIOS.jump = loadAudio("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/d0b815c7-f556-46cc-a896-d67fc30bca7a/jump%20wav-mRbWSSWc0662K03nFwo0XKjF2hohw1.wav?BMfF");
        AUDIOS.bullet = loadAudio("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/d0b815c7-f556-46cc-a896-d67fc30bca7a/bullet%20mp3-RbbsrYyG5xSbz0ga5LTO3GKFisiioP.mp3?HD3M");
        AUDIOS.monsterCrash = loadAudio("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/d0b815c7-f556-46cc-a896-d67fc30bca7a/monster-crash%20mp3-wt0wqXY6dkZmgSBm2IOajbxrwKTLzk.mp3?en9O");
        AUDIOS.trampSound = loadAudio("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/d0b815c7-f556-46cc-a896-d67fc30bca7a/trampoline%20mp3-g3V4oDhLadp6samjo7bEP1zilXzgaA.mp3?ZveD");
        AUDIOS.jetPack = loadAudio("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/d0b815c7-f556-46cc-a896-d67fc30bca7a/jetpack%20mp3-oSZY7Dunh8UDsWAsyMh7KiukxCUhvD.mp3?Y9gK");

        numAssets = assetsStillLoading;
        assetsLoadingLoop(callback);
      }

      loadAssets(() => {
        // Initialize audio pools with loaded audio sources
        audioManager.createPool('jump', AUDIOS.jump?.src || '', 4);
        audioManager.createPool('bullet', AUDIOS.bullet?.src || '', 5);
        audioManager.createPool('monsterCrash', AUDIOS.monsterCrash?.src || '', 3);
        audioManager.createPool('trampoline', AUDIOS.trampSound?.src || '', 3);
        audioManager.createPool('jetpack', AUDIOS.jetPack?.src || '', 2);

        // Create flipped player sprite for left-facing
        // Use canvas directly as image source (avoids tainted canvas toDataURL error)
        if (SPRITES.player && SPRITES.player.complete) {
          const canvas = document.createElement('canvas');
          canvas.width = SPRITES.player.width;
          canvas.height = SPRITES.player.height;
          const ctx = canvas.getContext('2d');
          ctx.translate(canvas.width, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(SPRITES.player, 0, 0);
          SPRITES.playerLeft = canvas;
        }

        window.theGame = new GAME(element);

        window.addEventListener("load", () => {
          setTimeout(() => {
            console.log("Calling Farcade ready...");
            window.FarcadeSDK?.singlePlayer?.actions.ready?.();
          }, 300);
        });
      });

      window.FarcadeSDK?.onPlayAgain?.(() => {
        if (window.theGame?.restartGame) {
          window.theGame.restartGame();
        }
      });

      window.FarcadeSDK?.onToggleMute?.((data) => {
        const isMuted = data?.isMuted;
        audioManager.setMuted(isMuted);
        for (let key in AUDIOS) {
          if (AUDIOS[key]) {
            AUDIOS[key].muted = isMuted;
          }
        }
      });

      // Touch controls (only if buttons exist)
      const leftBtn = document.getElementById("left-btn");
      const rightBtn = document.getElementById("right-btn");
      const shootBtn = document.getElementById("shoot-btn");

      if (leftBtn && rightBtn) {
        leftBtn.ontouchstart = () => {
          window.theGame.doodleXchange = -PLAYER_MOVE_SPEED;
          window.theGame.leftRight = 1;
        };
        rightBtn.ontouchstart = () => {
          window.theGame.doodleXchange = PLAYER_MOVE_SPEED;
          window.theGame.leftRight = 0;
        };
        leftBtn.ontouchend = rightBtn.ontouchend = () => {
          window.theGame.doodleXchange = 0;
        };
      }

      if (shootBtn) {
        shootBtn.ontouchstart = () => {
          if (window.theGame.spacePressed === 0) {
            window.theGame.leftRight = 2;
            window.theGame.shoot();
            window.theGame.spacePressed = 1;
            setTimeout(() => {
              window.theGame.spacePressed = 0;
            }, 200);
          }
        };
      }

      // Popup close
      window.addEventListener("load", () => {
        const popup = document.getElementById("popup-image");
        const closeBtn = document.getElementById("popup-close-btn");
        if (popup && closeBtn) {
          closeBtn.onclick = () => {
            popup.style.display = "none";
          };
        }
      });

      // Disable long-press context menu
      document.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      // Farcade SDK ready
      function waitForFarcadeAndReady(retries = 20) {
        if (typeof window.FarcadeSDK !== "undefined" && window.FarcadeSDK?.singlePlayer?.actions?.ready) {
          console.log("[OK] Farcade ready triggered");
          window.FarcadeSDK.singlePlayer.actions.ready();
        } else if (retries > 0) {
          setTimeout(() => waitForFarcadeAndReady(retries - 1), 250);
        } else {
          console.warn("[X] Farcade ready NOT triggered. SDK never loaded.");
        }
      }

      window.addEventListener("load", () => {
        waitForFarcadeAndReady();
      });
    </script>
  </body>
</html>
